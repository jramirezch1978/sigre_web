$PBExportHeader$f_numera_documento.srf
global type f_numera_documento from function_object
end type

forward prototypes
global function string f_numera_documento (string asi_table_name, long ali_length_code) throws exception
end prototypes

global function string f_numera_documento (string asi_table_name, long ali_length_code) throws exception;// Busca el numero en la tabla de numeradores pasada en el argumento y bloquea ese registro
// Si el numero no existe, bloquea la tabla y crea un nuevo registro
// Recibe nombre de tabla de numeradores y longitud del campo de numero a generar
// Devuelve un numero de documento con el formato origen + numero (XX9999...999)

String 				ls_next_nro, ls_execute, ls_table, ls_nro_act, ls_mensaje, ls_null
Long 					ll_next_nro, j, ll_long
n_cst_utilitario	lnvo_util
Exception			ex

try 
	ex 		 = create Exception
	
	ls_table = upper(trim(asi_table_name))
	
	delete tt_numerador;
	if SQLCA.SQLCode < 0 then
		ls_mensaje = SQLCA.SQLErrText
		ROLLBACK;
		ex.SetMessage('Function f_numera_documento. Error eliminando registros en tt_numerador, Mensaje: ' + ls_mensaje)
		throw ex
	end if
	
	//Bloquear la tabla numeradora
	ls_execute = "LOCK TABLE " + ls_table + " IN EXCLUSIVE MODE NOWAIT"
	execute immediate :ls_execute;
	if SQLCA.SQLCode < 0 then
		ls_mensaje = SQLCA.SQLErrText
		ROLLBACK;
		ex.SetMessage('Function f_numera_documento. Error en comando ' + ls_execute + ', Mensaje: ' + ls_mensaje)
		throw ex
	end if
	
	//Consulto la tabla numeradora
	ls_execute = "SELECT ult_nro FROM " + ls_table + " WHERE trim(origen) = '" + gs_origen + "' FOR UPDATE"
	execute immediate :ls_execute;
	if SQLCA.SQLCode < 0 then
		ls_mensaje = SQLCA.SQLErrText
		ROLLBACK;
		ex.SetMessage('Function f_numera_documento. Error en comando ' + ls_execute + ', Mensaje: ' + ls_mensaje)
		throw ex
	end if
	
	ls_execute = "INSERT INTO tt_numerador SELECT ult_nro FROM " + ls_table + " WHERE origen = '" + gs_origen + "'"
	execute immediate :ls_execute;
	if SQLCA.SQLCode < 0 then
		ls_mensaje = SQLCA.SQLErrText
		ROLLBACK;
		ex.SetMessage('Function f_numera_documento. Error en comando ' + ls_execute + ', Mensaje: ' + ls_mensaje)
		throw ex
	end if
	
	SELECT numerador 
		INTO :ll_next_nro 
	FROM tt_numerador;
	
	if SQLCA.SQLCode < 0 then
		ls_mensaje = SQLCA.SQLErrText
		ROLLBACK;
		ex.SetMessage('Function f_numera_documento. Error al consultar la tabla tt_numerador, Mensaje: ' + ls_mensaje)
		throw ex
	end if
	
	if isnull( ll_next_nro ) or ll_next_nro = 0 then
	
		ll_next_nro = 1
		ls_next_nro = String(ll_next_nro)
		
		ls_execute = "INSERT INTO " + ls_table + " (origen, ult_nro) VALUES ('" + gs_origen +"', " +ls_next_nro + ")"
		execute immediate :ls_execute;
		if SQLCA.SQLCode <> 0 then
			ls_mensaje = SQLCA.SQLErrText
			ROLLBACK;
			ex.SetMessage('Function f_numera_documento. Error en comando ' + ls_execute + ', Mensaje: ' + ls_mensaje)
			throw ex
		end if
	end if
	
	
	// Genero el numerador, pero como hexadecimal
	ll_long = ali_length_code - len(trim(gs_origen))
	
	if ll_long < 0 then
		ROLLBACK;
		ex.SetMessage('Function f_numera_documento. La longitud ' + string(ali_length_code) + ' no puede ser menor a a longitud del origen')
		throw ex
	end if
	
	ls_nro_act = trim(gs_origen) + trim(lnvo_util.lpad(lnvo_util.of_Long2Hex(ll_next_nro), ll_long, '0'))
	
	//Actualizo el numerador
	ls_execute = "UPDATE " + ls_table + " SET ult_nro = " + string(ll_next_nro +1) + " WHERE origen = '" + gs_origen +"'"
	execute immediate :ls_execute;
	if SQLCA.SQLCode <> 0 then
		ls_mensaje = SQLCA.SQLErrText
		ROLLBACK;
		MessageBox('Aviso', ls_mensaje)
		return ls_null
	end if
	
	
	return ls_nro_act

catch ( Exception e )
	throw e
finally
	destroy ex
	
	delete tt_numerador;
end try


end function

